// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2020-02-18 16:45:10.937727 +0000 UTC
package watcher

import (
	// "fmt"
	"context"
	"time"

	"github.com/davecgh/go-spew/spew"
	log "github.com/golang/glog"
	"github.com/pkg/errors"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"

	specs "github.com/joincivil/civil-events-crawler/pkg/contractspecs"
	"github.com/joincivil/civil-events-crawler/pkg/model"
	"github.com/joincivil/civil-events-crawler/pkg/utils"

	"github.com/joincivil/go-common/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"

	"math/big"
)

func NewMultiSigWalletContractWatchers(contractAddress common.Address) *MultiSigWalletContractWatchers {
	return &MultiSigWalletContractWatchers{
		contractAddress: contractAddress,
	}
}

type MultiSigWalletContractWatchers struct {
	errors          chan error
	contractAddress common.Address
	contract        *contract.MultiSigWalletContract
	activeSubs      []utils.WatcherSubscription
}

func (w *MultiSigWalletContractWatchers) ContractAddress() common.Address {
	return w.contractAddress
}

func (w *MultiSigWalletContractWatchers) ContractName() string {
	return "MultiSigWalletContract"
}

func (w *MultiSigWalletContractWatchers) cancelFunc(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
}

func (w *MultiSigWalletContractWatchers) StopWatchers(unsub bool) error {
	if unsub {
		for _, sub := range w.activeSubs {
			sub.Unsubscribe()
		}
	}
	w.activeSubs = nil
	w.contract = nil
	return nil
}

func (w *MultiSigWalletContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event, errs chan error) ([]utils.WatcherSubscription, error) {
	return w.StartMultiSigWalletContractWatchers(client, eventRecvChan, errs)
}

// StartMultiSigWalletContractWatchers starts up the event watchers for MultiSigWalletContract
func (w *MultiSigWalletContractWatchers) StartMultiSigWalletContractWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event, errs chan error) ([]utils.WatcherSubscription, error) {
	w.errors = errs
	contract, err := contract.NewMultiSigWalletContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartMultiSigWalletContract: err: %v", err)
		return nil, errors.Wrap(err, "error initializing StartMultiSigWalletContract")
	}
	w.contract = contract

	var sub utils.WatcherSubscription
	subs := []utils.WatcherSubscription{}

	if specs.IsListenerEnabledForEvent("MultiSigWalletContract", "Confirmation") {
		sub, err = w.startWatchConfirmation(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startConfirmation")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("MultiSigWalletContract", "Deposit") {
		sub, err = w.startWatchDeposit(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startDeposit")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("MultiSigWalletContract", "Execution") {
		sub, err = w.startWatchExecution(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startExecution")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("MultiSigWalletContract", "ExecutionFailure") {
		sub, err = w.startWatchExecutionFailure(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startExecutionFailure")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("MultiSigWalletContract", "OwnerAddition") {
		sub, err = w.startWatchOwnerAddition(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startOwnerAddition")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("MultiSigWalletContract", "OwnerRemoval") {
		sub, err = w.startWatchOwnerRemoval(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startOwnerRemoval")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("MultiSigWalletContract", "RequirementChange") {
		sub, err = w.startWatchRequirementChange(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startRequirementChange")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("MultiSigWalletContract", "Revocation") {
		sub, err = w.startWatchRevocation(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startRevocation")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("MultiSigWalletContract", "Submission") {
		sub, err = w.startWatchSubmission(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startSubmission")
		}
		subs = append(subs, sub)
	}

	w.activeSubs = subs
	return subs, nil
}

func (w *MultiSigWalletContractWatchers) startWatchConfirmation(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchConfirmation", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.MultiSigWalletContractConfirmation, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchConfirmation start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.MultiSigWalletContractConfirmation)
			sub, err := w.contract.WatchConfirmation(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchConfirmation: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchConfirmation")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchConfirmation: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchConfirmation: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchConfirmation: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchConfirmation")
				}
				modelEvent, err := model.NewEventFromContractEvent("Confirmation", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchConfirmation: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchConfirmation")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchConfirmation: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchConfirmation")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchConfirmation (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchConfirmation: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchConfirmation")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchConfirmation: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *MultiSigWalletContractWatchers) startWatchDeposit(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchDeposit", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.MultiSigWalletContractDeposit, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchDeposit start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.MultiSigWalletContractDeposit)
			sub, err := w.contract.WatchDeposit(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchDeposit: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchDeposit")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchDeposit: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchDeposit: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchDeposit: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchDeposit")
				}
				modelEvent, err := model.NewEventFromContractEvent("Deposit", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchDeposit: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchDeposit")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchDeposit: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchDeposit")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchDeposit (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchDeposit: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchDeposit")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchDeposit: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *MultiSigWalletContractWatchers) startWatchExecution(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchExecution", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.MultiSigWalletContractExecution, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchExecution start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.MultiSigWalletContractExecution)
			sub, err := w.contract.WatchExecution(
				opts,
				recvChan,
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchExecution: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchExecution")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchExecution: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchExecution: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchExecution: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchExecution")
				}
				modelEvent, err := model.NewEventFromContractEvent("Execution", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchExecution: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchExecution")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchExecution: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchExecution")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchExecution (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchExecution: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchExecution")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchExecution: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *MultiSigWalletContractWatchers) startWatchExecutionFailure(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchExecutionFailure", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.MultiSigWalletContractExecutionFailure, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchExecutionFailure start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.MultiSigWalletContractExecutionFailure)
			sub, err := w.contract.WatchExecutionFailure(
				opts,
				recvChan,
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchExecutionFailure: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchExecutionFailure")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchExecutionFailure: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchExecutionFailure: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchExecutionFailure: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchExecutionFailure")
				}
				modelEvent, err := model.NewEventFromContractEvent("ExecutionFailure", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchExecutionFailure: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchExecutionFailure")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchExecutionFailure: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchExecutionFailure")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchExecutionFailure (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchExecutionFailure: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchExecutionFailure")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchExecutionFailure: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *MultiSigWalletContractWatchers) startWatchOwnerAddition(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchOwnerAddition", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.MultiSigWalletContractOwnerAddition, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchOwnerAddition start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.MultiSigWalletContractOwnerAddition)
			sub, err := w.contract.WatchOwnerAddition(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchOwnerAddition: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchOwnerAddition")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchOwnerAddition: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchOwnerAddition: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchOwnerAddition: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchOwnerAddition")
				}
				modelEvent, err := model.NewEventFromContractEvent("OwnerAddition", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchOwnerAddition: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchOwnerAddition")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchOwnerAddition: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchOwnerAddition")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchOwnerAddition (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchOwnerAddition: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchOwnerAddition")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchOwnerAddition: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *MultiSigWalletContractWatchers) startWatchOwnerRemoval(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchOwnerRemoval", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.MultiSigWalletContractOwnerRemoval, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchOwnerRemoval start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.MultiSigWalletContractOwnerRemoval)
			sub, err := w.contract.WatchOwnerRemoval(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchOwnerRemoval: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchOwnerRemoval")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchOwnerRemoval: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchOwnerRemoval: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchOwnerRemoval: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchOwnerRemoval")
				}
				modelEvent, err := model.NewEventFromContractEvent("OwnerRemoval", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchOwnerRemoval: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchOwnerRemoval")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchOwnerRemoval: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchOwnerRemoval")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchOwnerRemoval (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchOwnerRemoval: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchOwnerRemoval")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchOwnerRemoval: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *MultiSigWalletContractWatchers) startWatchRequirementChange(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchRequirementChange", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.MultiSigWalletContractRequirementChange, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchRequirementChange start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.MultiSigWalletContractRequirementChange)
			sub, err := w.contract.WatchRequirementChange(
				opts,
				recvChan,
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchRequirementChange: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchRequirementChange")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchRequirementChange: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchRequirementChange: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchRequirementChange: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchRequirementChange")
				}
				modelEvent, err := model.NewEventFromContractEvent("RequirementChange", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchRequirementChange: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchRequirementChange")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchRequirementChange: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchRequirementChange")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchRequirementChange (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchRequirementChange: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchRequirementChange")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchRequirementChange: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *MultiSigWalletContractWatchers) startWatchRevocation(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchRevocation", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.MultiSigWalletContractRevocation, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchRevocation start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.MultiSigWalletContractRevocation)
			sub, err := w.contract.WatchRevocation(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchRevocation: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchRevocation")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchRevocation: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchRevocation: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchRevocation: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchRevocation")
				}
				modelEvent, err := model.NewEventFromContractEvent("Revocation", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchRevocation: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchRevocation")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchRevocation: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchRevocation")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchRevocation (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchRevocation: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchRevocation")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchRevocation: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *MultiSigWalletContractWatchers) startWatchSubmission(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchSubmission", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.MultiSigWalletContractSubmission, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchSubmission start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.MultiSigWalletContractSubmission)
			sub, err := w.contract.WatchSubmission(
				opts,
				recvChan,
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchSubmission: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchSubmission")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchSubmission: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchSubmission: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchSubmission: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchSubmission")
				}
				modelEvent, err := model.NewEventFromContractEvent("Submission", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchSubmission: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchSubmission")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchSubmission: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchSubmission")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchSubmission (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchSubmission: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchSubmission")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchSubmission: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}
