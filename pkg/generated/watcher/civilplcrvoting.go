// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2019-12-10 22:15:54.320596 +0000 UTC
package watcher

import (
	// "fmt"
	"context"
	"time"

	"github.com/davecgh/go-spew/spew"
	log "github.com/golang/glog"
	"github.com/pkg/errors"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"

	specs "github.com/joincivil/civil-events-crawler/pkg/contractspecs"
	"github.com/joincivil/civil-events-crawler/pkg/model"
	"github.com/joincivil/civil-events-crawler/pkg/utils"

	"github.com/joincivil/go-common/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"

	"math/big"
)

func NewCivilPLCRVotingContractWatchers(contractAddress common.Address) *CivilPLCRVotingContractWatchers {
	return &CivilPLCRVotingContractWatchers{
		contractAddress: contractAddress,
	}
}

type CivilPLCRVotingContractWatchers struct {
	errors          chan error
	contractAddress common.Address
	contract        *contract.CivilPLCRVotingContract
	activeSubs      []utils.WatcherSubscription
}

func (w *CivilPLCRVotingContractWatchers) ContractAddress() common.Address {
	return w.contractAddress
}

func (w *CivilPLCRVotingContractWatchers) ContractName() string {
	return "CivilPLCRVotingContract"
}

func (w *CivilPLCRVotingContractWatchers) cancelFunc(cancelFn context.CancelFunc, killCancel <-chan bool) {
}

func (w *CivilPLCRVotingContractWatchers) StopWatchers(unsub bool) error {
	if unsub {
		for _, sub := range w.activeSubs {
			sub.Unsubscribe()
		}
	}
	w.activeSubs = nil
	return nil
}

func (w *CivilPLCRVotingContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event, errs chan error) ([]utils.WatcherSubscription, error) {
	return w.StartCivilPLCRVotingContractWatchers(client, eventRecvChan, errs)
}

// StartCivilPLCRVotingContractWatchers starts up the event watchers for CivilPLCRVotingContract
func (w *CivilPLCRVotingContractWatchers) StartCivilPLCRVotingContractWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event, errs chan error) ([]utils.WatcherSubscription, error) {
	w.errors = errs
	contract, err := contract.NewCivilPLCRVotingContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilPLCRVotingContract: err: %v", err)
		return nil, errors.Wrap(err, "error initializing StartCivilPLCRVotingContract")
	}
	w.contract = contract

	var sub utils.WatcherSubscription
	subs := []utils.WatcherSubscription{}

	if specs.IsListenerEnabledForEvent("CivilPLCRVotingContract", "PollCreated") {
		sub, err = w.startWatchPollCreated(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startPollCreated")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilPLCRVotingContract", "TokensRescued") {
		sub, err = w.startWatchTokensRescued(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startTokensRescued")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilPLCRVotingContract", "VoteCommitted") {
		sub, err = w.startWatchVoteCommitted(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startVoteCommitted")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilPLCRVotingContract", "VoteRevealed") {
		sub, err = w.startWatchVoteRevealed(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startVoteRevealed")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilPLCRVotingContract", "VotingRightsGranted") {
		sub, err = w.startWatchVotingRightsGranted(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startVotingRightsGranted")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilPLCRVotingContract", "VotingRightsWithdrawn") {
		sub, err = w.startWatchVotingRightsWithdrawn(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startVotingRightsWithdrawn")
		}
		subs = append(subs, sub)
	}

	w.activeSubs = subs
	return subs, nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchPollCreated(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchPollCreated", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilPLCRVotingContractPollCreated, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchPollCreated start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilPLCRVotingContractPollCreated)
			log.Infof("startupFn: Starting WatchPollCreated: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchPollCreated(
				opts,
				recvChan,
				[]*big.Int{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchPollCreated: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchPollCreated")
			}
			log.Infof("startupFn: WatchPollCreated started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchPollCreated: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchPollCreated: addr: %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of PollCreated")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting PollCreated: addr: %v, %v", w.contractAddress.Hex(), err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old PollCreated")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart PollCreated: addr: %v", w.contractAddress.Hex())
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchPollCreated: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchPollCreated")
				}
				modelEvent, err := model.NewEventFromContractEvent("PollCreated", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchPollCreated: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchPollCreated")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchPollCreated: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchPollCreated")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchPollCreated (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchPollCreated: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchPollCreated")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchPollCreated: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchTokensRescued(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchTokensRescued", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilPLCRVotingContractTokensRescued, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchTokensRescued start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilPLCRVotingContractTokensRescued)
			log.Infof("startupFn: Starting WatchTokensRescued: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchTokensRescued(
				opts,
				recvChan,
				[]*big.Int{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchTokensRescued: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchTokensRescued")
			}
			log.Infof("startupFn: WatchTokensRescued started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchTokensRescued: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchTokensRescued: addr: %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of TokensRescued")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting TokensRescued: addr: %v, %v", w.contractAddress.Hex(), err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old TokensRescued")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart TokensRescued: addr: %v", w.contractAddress.Hex())
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchTokensRescued: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchTokensRescued")
				}
				modelEvent, err := model.NewEventFromContractEvent("TokensRescued", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchTokensRescued: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchTokensRescued")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchTokensRescued: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchTokensRescued")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchTokensRescued (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchTokensRescued: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchTokensRescued")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchTokensRescued: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchVoteCommitted(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchVoteCommitted", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilPLCRVotingContractVoteCommitted, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchVoteCommitted start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilPLCRVotingContractVoteCommitted)
			log.Infof("startupFn: Starting WatchVoteCommitted: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchVoteCommitted(
				opts,
				recvChan,
				[]*big.Int{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchVoteCommitted: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchVoteCommitted")
			}
			log.Infof("startupFn: WatchVoteCommitted started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchVoteCommitted: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchVoteCommitted: addr: %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of VoteCommitted")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting VoteCommitted: addr: %v, %v", w.contractAddress.Hex(), err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old VoteCommitted")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart VoteCommitted: addr: %v", w.contractAddress.Hex())
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchVoteCommitted: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchVoteCommitted")
				}
				modelEvent, err := model.NewEventFromContractEvent("VoteCommitted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchVoteCommitted: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchVoteCommitted")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchVoteCommitted: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchVoteCommitted")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchVoteCommitted (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchVoteCommitted: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchVoteCommitted")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchVoteCommitted: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchVoteRevealed(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchVoteRevealed", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilPLCRVotingContractVoteRevealed, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchVoteRevealed start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilPLCRVotingContractVoteRevealed)
			log.Infof("startupFn: Starting WatchVoteRevealed: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchVoteRevealed(
				opts,
				recvChan,
				[]*big.Int{},
				[]*big.Int{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchVoteRevealed: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchVoteRevealed")
			}
			log.Infof("startupFn: WatchVoteRevealed started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchVoteRevealed: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchVoteRevealed: addr: %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of VoteRevealed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting VoteRevealed: addr: %v, %v", w.contractAddress.Hex(), err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old VoteRevealed")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart VoteRevealed: addr: %v", w.contractAddress.Hex())
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchVoteRevealed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchVoteRevealed")
				}
				modelEvent, err := model.NewEventFromContractEvent("VoteRevealed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchVoteRevealed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchVoteRevealed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchVoteRevealed: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchVoteRevealed")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchVoteRevealed (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchVoteRevealed: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchVoteRevealed")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchVoteRevealed: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchVotingRightsGranted(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchVotingRightsGranted", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilPLCRVotingContractVotingRightsGranted, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchVotingRightsGranted start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilPLCRVotingContractVotingRightsGranted)
			log.Infof("startupFn: Starting WatchVotingRightsGranted: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchVotingRightsGranted(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchVotingRightsGranted: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchVotingRightsGranted")
			}
			log.Infof("startupFn: WatchVotingRightsGranted started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchVotingRightsGranted: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchVotingRightsGranted: addr: %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of VotingRightsGranted")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting VotingRightsGranted: addr: %v, %v", w.contractAddress.Hex(), err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old VotingRightsGranted")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart VotingRightsGranted: addr: %v", w.contractAddress.Hex())
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchVotingRightsGranted: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchVotingRightsGranted")
				}
				modelEvent, err := model.NewEventFromContractEvent("VotingRightsGranted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchVotingRightsGranted: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchVotingRightsGranted")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchVotingRightsGranted: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchVotingRightsGranted")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchVotingRightsGranted (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchVotingRightsGranted: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchVotingRightsGranted")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchVotingRightsGranted: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilPLCRVotingContractWatchers) startWatchVotingRightsWithdrawn(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchVotingRightsWithdrawn", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilPLCRVotingContractVotingRightsWithdrawn, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchVotingRightsWithdrawn start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilPLCRVotingContractVotingRightsWithdrawn)
			log.Infof("startupFn: Starting WatchVotingRightsWithdrawn: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchVotingRightsWithdrawn(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchVotingRightsWithdrawn: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchVotingRightsWithdrawn")
			}
			log.Infof("startupFn: WatchVotingRightsWithdrawn started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchVotingRightsWithdrawn: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchVotingRightsWithdrawn: addr: %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of VotingRightsWithdrawn")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting VotingRightsWithdrawn: addr: %v, %v", w.contractAddress.Hex(), err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old VotingRightsWithdrawn")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart VotingRightsWithdrawn: addr: %v", w.contractAddress.Hex())
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchVotingRightsWithdrawn: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchVotingRightsWithdrawn")
				}
				modelEvent, err := model.NewEventFromContractEvent("VotingRightsWithdrawn", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchVotingRightsWithdrawn: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchVotingRightsWithdrawn")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchVotingRightsWithdrawn: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchVotingRightsWithdrawn")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchVotingRightsWithdrawn (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchVotingRightsWithdrawn: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchVotingRightsWithdrawn")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchVotingRightsWithdrawn: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}
