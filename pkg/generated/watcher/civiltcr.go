// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2019-03-20 17:54:51.783082 +0000 UTC
package watcher

import (
	// "fmt"
	"context"
	"time"

	"github.com/davecgh/go-spew/spew"
	log "github.com/golang/glog"
	"github.com/pkg/errors"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"

	"github.com/joincivil/civil-events-crawler/pkg/model"
	"github.com/joincivil/civil-events-crawler/pkg/utils"

	"github.com/joincivil/go-common/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"

	"math/big"
)

func NewCivilTCRContractWatchers(contractAddress common.Address) *CivilTCRContractWatchers {
	return &CivilTCRContractWatchers{
		contractAddress: contractAddress,
	}
}

type CivilTCRContractWatchers struct {
	errors          chan error
	contractAddress common.Address
	contract        *contract.CivilTCRContract
	activeSubs      []utils.WatcherSubscription
}

func (w *CivilTCRContractWatchers) ContractAddress() common.Address {
	return w.contractAddress
}

func (w *CivilTCRContractWatchers) ContractName() string {
	return "CivilTCRContract"
}

func (w *CivilTCRContractWatchers) cancelFunc(cancelFn context.CancelFunc, killCancel <-chan bool) {
}

func (w *CivilTCRContractWatchers) StopWatchers(unsub bool) error {
	if unsub {
		for _, sub := range w.activeSubs {
			sub.Unsubscribe()
		}
	}
	w.activeSubs = nil
	return nil
}

func (w *CivilTCRContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event, errs chan error) ([]utils.WatcherSubscription, error) {
	return w.StartCivilTCRContractWatchers(client, eventRecvChan, errs)
}

// StartCivilTCRContractWatchers starts up the event watchers for CivilTCRContract
func (w *CivilTCRContractWatchers) StartCivilTCRContractWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event, errs chan error) ([]utils.WatcherSubscription, error) {
	w.errors = errs
	contract, err := contract.NewCivilTCRContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilTCRContract: err: %v", err)
		return nil, errors.Wrap(err, "error initializing StartCivilTCRContract")
	}
	w.contract = contract

	var sub utils.WatcherSubscription
	subs := []utils.WatcherSubscription{}

	sub, err = w.startWatchAppealGranted(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startAppealGranted")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchAppealRequested(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startAppealRequested")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplication(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startApplication")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplicationRemoved(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startApplicationRemoved")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchApplicationWhitelisted(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startApplicationWhitelisted")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallenge(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startChallenge")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallengeFailed(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startChallengeFailed")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchChallengeSucceeded(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startChallengeSucceeded")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchDeposit(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startDeposit")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchFailedChallengeOverturned(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startFailedChallengeOverturned")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGovernmentTransfered(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startGovernmentTransfered")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealChallenged(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startGrantedAppealChallenged")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealConfirmed(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startGrantedAppealConfirmed")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchGrantedAppealOverturned(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startGrantedAppealOverturned")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchListingRemoved(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startListingRemoved")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchListingWithdrawn(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startListingWithdrawn")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchRewardClaimed(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startRewardClaimed")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchSuccessfulChallengeOverturned(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startSuccessfulChallengeOverturned")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchTouchAndRemoved(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startTouchAndRemoved")
	}
	subs = append(subs, sub)

	sub, err = w.startWatchWithdrawal(eventRecvChan)
	if err != nil {
		return nil, errors.WithMessage(err, "error starting startWithdrawal")
	}
	subs = append(subs, sub)

	w.activeSubs = subs
	return subs, nil
}

func (w *CivilTCRContractWatchers) startWatchAppealGranted(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchAppealGranted", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractAppealGranted, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchAppealGranted start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractAppealGranted)
			log.Infof("startupFn: Starting WatchAppealGranted")
			sub, err := w.contract.WatchAppealGranted(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchAppealGranted")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchAppealGranted")
			}
			log.Infof("startupFn: WatchAppealGranted started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchAppealGranted: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchAppealGranted for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of AppealGranted")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting AppealGranted: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old AppealGranted")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart AppealGranted")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchAppealGranted: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchAppealGranted")
				}
				modelEvent, err := model.NewEventFromContractEvent("AppealGranted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchAppealGranted: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchAppealGranted")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchAppealGranted, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchAppealGranted")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchAppealGranted (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchAppealGranted, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchAppealGranted")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchAppealGranted")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchAppealRequested(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchAppealRequested", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractAppealRequested, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchAppealRequested start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractAppealRequested)
			log.Infof("startupFn: Starting WatchAppealRequested")
			sub, err := w.contract.WatchAppealRequested(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchAppealRequested")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchAppealRequested")
			}
			log.Infof("startupFn: WatchAppealRequested started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchAppealRequested: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchAppealRequested for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of AppealRequested")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting AppealRequested: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old AppealRequested")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart AppealRequested")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchAppealRequested: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchAppealRequested")
				}
				modelEvent, err := model.NewEventFromContractEvent("AppealRequested", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchAppealRequested: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchAppealRequested")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchAppealRequested, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchAppealRequested")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchAppealRequested (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchAppealRequested, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchAppealRequested")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchAppealRequested")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplication(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchApplication", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractApplication, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchApplication start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractApplication)
			log.Infof("startupFn: Starting WatchApplication")
			sub, err := w.contract.WatchApplication(
				opts,
				recvChan,
				[]common.Address{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchApplication")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchApplication")
			}
			log.Infof("startupFn: WatchApplication started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplication: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchApplication for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of Application")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting Application: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old Application")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart Application")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchApplication: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchApplication")
				}
				modelEvent, err := model.NewEventFromContractEvent("Application", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchApplication: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchApplication")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchApplication, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchApplication")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchApplication (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchApplication, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchApplication")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchApplication")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplicationRemoved(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchApplicationRemoved", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractApplicationRemoved, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchApplicationRemoved start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractApplicationRemoved)
			log.Infof("startupFn: Starting WatchApplicationRemoved")
			sub, err := w.contract.WatchApplicationRemoved(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchApplicationRemoved")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchApplicationRemoved")
			}
			log.Infof("startupFn: WatchApplicationRemoved started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplicationRemoved: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchApplicationRemoved for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of ApplicationRemoved")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ApplicationRemoved: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old ApplicationRemoved")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ApplicationRemoved")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchApplicationRemoved: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchApplicationRemoved")
				}
				modelEvent, err := model.NewEventFromContractEvent("ApplicationRemoved", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchApplicationRemoved: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchApplicationRemoved")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchApplicationRemoved, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchApplicationRemoved")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchApplicationRemoved (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchApplicationRemoved, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchApplicationRemoved")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchApplicationRemoved")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplicationWhitelisted(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchApplicationWhitelisted", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractApplicationWhitelisted, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchApplicationWhitelisted start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractApplicationWhitelisted)
			log.Infof("startupFn: Starting WatchApplicationWhitelisted")
			sub, err := w.contract.WatchApplicationWhitelisted(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchApplicationWhitelisted")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchApplicationWhitelisted")
			}
			log.Infof("startupFn: WatchApplicationWhitelisted started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplicationWhitelisted: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchApplicationWhitelisted for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of ApplicationWhitelisted")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ApplicationWhitelisted: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old ApplicationWhitelisted")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ApplicationWhitelisted")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchApplicationWhitelisted: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchApplicationWhitelisted")
				}
				modelEvent, err := model.NewEventFromContractEvent("ApplicationWhitelisted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchApplicationWhitelisted: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchApplicationWhitelisted")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchApplicationWhitelisted, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchApplicationWhitelisted")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchApplicationWhitelisted (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchApplicationWhitelisted, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchApplicationWhitelisted")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchApplicationWhitelisted")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallenge(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchChallenge", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractChallenge, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchChallenge start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractChallenge)
			log.Infof("startupFn: Starting WatchChallenge")
			sub, err := w.contract.WatchChallenge(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchChallenge")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchChallenge")
			}
			log.Infof("startupFn: WatchChallenge started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallenge: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallenge for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of Challenge")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting Challenge: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old Challenge")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart Challenge")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallenge: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallenge")
				}
				modelEvent, err := model.NewEventFromContractEvent("Challenge", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchChallenge: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchChallenge")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallenge, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchChallenge")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchChallenge (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallenge, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchChallenge")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchChallenge")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallengeFailed(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchChallengeFailed", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractChallengeFailed, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchChallengeFailed start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractChallengeFailed)
			log.Infof("startupFn: Starting WatchChallengeFailed")
			sub, err := w.contract.WatchChallengeFailed(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchChallengeFailed")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchChallengeFailed")
			}
			log.Infof("startupFn: WatchChallengeFailed started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeFailed: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallengeFailed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of ChallengeFailed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ChallengeFailed: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old ChallengeFailed")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ChallengeFailed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallengeFailed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallengeFailed")
				}
				modelEvent, err := model.NewEventFromContractEvent("ChallengeFailed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchChallengeFailed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchChallengeFailed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallengeFailed, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchChallengeFailed")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchChallengeFailed (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallengeFailed, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchChallengeFailed")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchChallengeFailed")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallengeSucceeded(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchChallengeSucceeded", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractChallengeSucceeded, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchChallengeSucceeded start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractChallengeSucceeded)
			log.Infof("startupFn: Starting WatchChallengeSucceeded")
			sub, err := w.contract.WatchChallengeSucceeded(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchChallengeSucceeded")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchChallengeSucceeded")
			}
			log.Infof("startupFn: WatchChallengeSucceeded started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeSucceeded: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchChallengeSucceeded for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of ChallengeSucceeded")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ChallengeSucceeded: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old ChallengeSucceeded")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ChallengeSucceeded")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallengeSucceeded: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallengeSucceeded")
				}
				modelEvent, err := model.NewEventFromContractEvent("ChallengeSucceeded", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchChallengeSucceeded: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchChallengeSucceeded")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallengeSucceeded, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchChallengeSucceeded")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchChallengeSucceeded (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallengeSucceeded, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchChallengeSucceeded")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchChallengeSucceeded")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchDeposit(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchDeposit", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractDeposit, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchDeposit start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractDeposit)
			log.Infof("startupFn: Starting WatchDeposit")
			sub, err := w.contract.WatchDeposit(
				opts,
				recvChan,
				[]common.Address{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchDeposit")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchDeposit")
			}
			log.Infof("startupFn: WatchDeposit started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchDeposit: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchDeposit for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of Deposit")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting Deposit: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old Deposit")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart Deposit")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchDeposit: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchDeposit")
				}
				modelEvent, err := model.NewEventFromContractEvent("Deposit", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchDeposit: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchDeposit")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchDeposit, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchDeposit")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchDeposit (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchDeposit, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchDeposit")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchDeposit")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchFailedChallengeOverturned(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchFailedChallengeOverturned", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractFailedChallengeOverturned, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchFailedChallengeOverturned start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractFailedChallengeOverturned)
			log.Infof("startupFn: Starting WatchFailedChallengeOverturned")
			sub, err := w.contract.WatchFailedChallengeOverturned(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchFailedChallengeOverturned")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchFailedChallengeOverturned")
			}
			log.Infof("startupFn: WatchFailedChallengeOverturned started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchFailedChallengeOverturned: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchFailedChallengeOverturned for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of FailedChallengeOverturned")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting FailedChallengeOverturned: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old FailedChallengeOverturned")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart FailedChallengeOverturned")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchFailedChallengeOverturned: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchFailedChallengeOverturned")
				}
				modelEvent, err := model.NewEventFromContractEvent("FailedChallengeOverturned", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchFailedChallengeOverturned: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchFailedChallengeOverturned")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchFailedChallengeOverturned, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchFailedChallengeOverturned")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchFailedChallengeOverturned (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchFailedChallengeOverturned, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchFailedChallengeOverturned")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchFailedChallengeOverturned")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGovernmentTransfered(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchGovernmentTransfered", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractGovernmentTransfered, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchGovernmentTransfered start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractGovernmentTransfered)
			log.Infof("startupFn: Starting WatchGovernmentTransfered")
			sub, err := w.contract.WatchGovernmentTransfered(
				opts,
				recvChan,
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchGovernmentTransfered")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchGovernmentTransfered")
			}
			log.Infof("startupFn: WatchGovernmentTransfered started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGovernmentTransfered: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGovernmentTransfered for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of GovernmentTransfered")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting GovernmentTransfered: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old GovernmentTransfered")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart GovernmentTransfered")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGovernmentTransfered: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGovernmentTransfered")
				}
				modelEvent, err := model.NewEventFromContractEvent("GovernmentTransfered", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchGovernmentTransfered: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchGovernmentTransfered")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchGovernmentTransfered, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchGovernmentTransfered")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchGovernmentTransfered (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGovernmentTransfered, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchGovernmentTransfered")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchGovernmentTransfered")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealChallenged(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchGrantedAppealChallenged", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractGrantedAppealChallenged, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchGrantedAppealChallenged start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractGrantedAppealChallenged)
			log.Infof("startupFn: Starting WatchGrantedAppealChallenged")
			sub, err := w.contract.WatchGrantedAppealChallenged(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchGrantedAppealChallenged")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchGrantedAppealChallenged")
			}
			log.Infof("startupFn: WatchGrantedAppealChallenged started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealChallenged: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGrantedAppealChallenged for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of GrantedAppealChallenged")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting GrantedAppealChallenged: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old GrantedAppealChallenged")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart GrantedAppealChallenged")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGrantedAppealChallenged: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGrantedAppealChallenged")
				}
				modelEvent, err := model.NewEventFromContractEvent("GrantedAppealChallenged", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchGrantedAppealChallenged: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchGrantedAppealChallenged")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchGrantedAppealChallenged, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchGrantedAppealChallenged")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchGrantedAppealChallenged (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGrantedAppealChallenged, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchGrantedAppealChallenged")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchGrantedAppealChallenged")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealConfirmed(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchGrantedAppealConfirmed", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractGrantedAppealConfirmed, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchGrantedAppealConfirmed start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractGrantedAppealConfirmed)
			log.Infof("startupFn: Starting WatchGrantedAppealConfirmed")
			sub, err := w.contract.WatchGrantedAppealConfirmed(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchGrantedAppealConfirmed")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchGrantedAppealConfirmed")
			}
			log.Infof("startupFn: WatchGrantedAppealConfirmed started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealConfirmed: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGrantedAppealConfirmed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of GrantedAppealConfirmed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting GrantedAppealConfirmed: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old GrantedAppealConfirmed")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart GrantedAppealConfirmed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGrantedAppealConfirmed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGrantedAppealConfirmed")
				}
				modelEvent, err := model.NewEventFromContractEvent("GrantedAppealConfirmed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchGrantedAppealConfirmed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchGrantedAppealConfirmed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchGrantedAppealConfirmed, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchGrantedAppealConfirmed")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchGrantedAppealConfirmed (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGrantedAppealConfirmed, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchGrantedAppealConfirmed")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchGrantedAppealConfirmed")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealOverturned(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchGrantedAppealOverturned", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractGrantedAppealOverturned, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchGrantedAppealOverturned start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractGrantedAppealOverturned)
			log.Infof("startupFn: Starting WatchGrantedAppealOverturned")
			sub, err := w.contract.WatchGrantedAppealOverturned(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchGrantedAppealOverturned")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchGrantedAppealOverturned")
			}
			log.Infof("startupFn: WatchGrantedAppealOverturned started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealOverturned: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchGrantedAppealOverturned for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of GrantedAppealOverturned")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting GrantedAppealOverturned: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old GrantedAppealOverturned")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart GrantedAppealOverturned")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGrantedAppealOverturned: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGrantedAppealOverturned")
				}
				modelEvent, err := model.NewEventFromContractEvent("GrantedAppealOverturned", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchGrantedAppealOverturned: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchGrantedAppealOverturned")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchGrantedAppealOverturned, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchGrantedAppealOverturned")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchGrantedAppealOverturned (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGrantedAppealOverturned, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchGrantedAppealOverturned")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchGrantedAppealOverturned")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchListingRemoved(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchListingRemoved", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractListingRemoved, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchListingRemoved start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractListingRemoved)
			log.Infof("startupFn: Starting WatchListingRemoved")
			sub, err := w.contract.WatchListingRemoved(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchListingRemoved")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchListingRemoved")
			}
			log.Infof("startupFn: WatchListingRemoved started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchListingRemoved: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchListingRemoved for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of ListingRemoved")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ListingRemoved: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old ListingRemoved")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ListingRemoved")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchListingRemoved: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchListingRemoved")
				}
				modelEvent, err := model.NewEventFromContractEvent("ListingRemoved", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchListingRemoved: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchListingRemoved")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchListingRemoved, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchListingRemoved")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchListingRemoved (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchListingRemoved, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchListingRemoved")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchListingRemoved")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchListingWithdrawn(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchListingWithdrawn", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractListingWithdrawn, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchListingWithdrawn start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractListingWithdrawn)
			log.Infof("startupFn: Starting WatchListingWithdrawn")
			sub, err := w.contract.WatchListingWithdrawn(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchListingWithdrawn")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchListingWithdrawn")
			}
			log.Infof("startupFn: WatchListingWithdrawn started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchListingWithdrawn: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchListingWithdrawn for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of ListingWithdrawn")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting ListingWithdrawn: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old ListingWithdrawn")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart ListingWithdrawn")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchListingWithdrawn: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchListingWithdrawn")
				}
				modelEvent, err := model.NewEventFromContractEvent("ListingWithdrawn", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchListingWithdrawn: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchListingWithdrawn")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchListingWithdrawn, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchListingWithdrawn")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchListingWithdrawn (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchListingWithdrawn, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchListingWithdrawn")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchListingWithdrawn")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchRewardClaimed(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchRewardClaimed", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractRewardClaimed, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchRewardClaimed start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractRewardClaimed)
			log.Infof("startupFn: Starting WatchRewardClaimed")
			sub, err := w.contract.WatchRewardClaimed(
				opts,
				recvChan,
				[]*big.Int{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchRewardClaimed")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchRewardClaimed")
			}
			log.Infof("startupFn: WatchRewardClaimed started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchRewardClaimed: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchRewardClaimed for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of RewardClaimed")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting RewardClaimed: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old RewardClaimed")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart RewardClaimed")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchRewardClaimed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchRewardClaimed")
				}
				modelEvent, err := model.NewEventFromContractEvent("RewardClaimed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchRewardClaimed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchRewardClaimed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchRewardClaimed, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchRewardClaimed")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchRewardClaimed (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchRewardClaimed, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchRewardClaimed")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchRewardClaimed")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchSuccessfulChallengeOverturned(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchSuccessfulChallengeOverturned", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractSuccessfulChallengeOverturned, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchSuccessfulChallengeOverturned start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractSuccessfulChallengeOverturned)
			log.Infof("startupFn: Starting WatchSuccessfulChallengeOverturned")
			sub, err := w.contract.WatchSuccessfulChallengeOverturned(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchSuccessfulChallengeOverturned")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchSuccessfulChallengeOverturned")
			}
			log.Infof("startupFn: WatchSuccessfulChallengeOverturned started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchSuccessfulChallengeOverturned: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchSuccessfulChallengeOverturned for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of SuccessfulChallengeOverturned")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting SuccessfulChallengeOverturned: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old SuccessfulChallengeOverturned")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart SuccessfulChallengeOverturned")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchSuccessfulChallengeOverturned: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchSuccessfulChallengeOverturned")
				}
				modelEvent, err := model.NewEventFromContractEvent("SuccessfulChallengeOverturned", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchSuccessfulChallengeOverturned: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchSuccessfulChallengeOverturned")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchSuccessfulChallengeOverturned, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchSuccessfulChallengeOverturned")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchSuccessfulChallengeOverturned (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchSuccessfulChallengeOverturned, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchSuccessfulChallengeOverturned")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchSuccessfulChallengeOverturned")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchTouchAndRemoved(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchTouchAndRemoved", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractTouchAndRemoved, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchTouchAndRemoved start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractTouchAndRemoved)
			log.Infof("startupFn: Starting WatchTouchAndRemoved")
			sub, err := w.contract.WatchTouchAndRemoved(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchTouchAndRemoved")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchTouchAndRemoved")
			}
			log.Infof("startupFn: WatchTouchAndRemoved started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchTouchAndRemoved: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchTouchAndRemoved for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of TouchAndRemoved")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting TouchAndRemoved: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old TouchAndRemoved")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart TouchAndRemoved")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchTouchAndRemoved: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchTouchAndRemoved")
				}
				modelEvent, err := model.NewEventFromContractEvent("TouchAndRemoved", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchTouchAndRemoved: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchTouchAndRemoved")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchTouchAndRemoved, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchTouchAndRemoved")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchTouchAndRemoved (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchTouchAndRemoved, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchTouchAndRemoved")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchTouchAndRemoved")
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchWithdrawal(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	preemptiveTimeoutSecs := 60 * 30
	return utils.NewWatcherSubscription("WatchWithdrawal", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractWithdrawal, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchWithdrawal start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractWithdrawal)
			log.Infof("startupFn: Starting WatchWithdrawal")
			sub, err := w.contract.WatchWithdrawal(
				opts,
				recvChan,
				[]common.Address{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchWithdrawal")
					sub.Unsubscribe()
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchWithdrawal")
			}
			log.Infof("startupFn: WatchWithdrawal started")
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchWithdrawal: %v", err)
			if sub != nil {
				sub.Unsubscribe()
			}
			w.errors <- err
			return err
		}
		defer sub.Unsubscribe()
		log.Infof("Starting up WatchWithdrawal for contract %v", w.contractAddress.Hex())
		for {
			select {
			// 30 min premptive resubscribe
			case <-time.After(time.Second * time.Duration(preemptiveTimeoutSecs)):
				log.Infof("Premptive restart of Withdrawal")
				oldSub := sub
				sub, recvChan, err = startupFn()
				if err != nil {
					log.Errorf("Error starting Withdrawal: %v", err)
					w.errors <- err
					return err
				}
				log.Infof("Attempting to unsub old Withdrawal")
				oldSub.Unsubscribe()
				log.Infof("Done preemptive restart Withdrawal")
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchWithdrawal: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchWithdrawal")
				}
				modelEvent, err := model.NewEventFromContractEvent("Withdrawal", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchWithdrawal: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchWithdrawal")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchWithdrawal, fatal (a): %v", err)
					err = errors.Wrap(err, "error with WatchWithdrawal")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchWithdrawal (a): %v", err)
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchWithdrawal, fatal (b): %v", err)
				err = errors.Wrap(err, "error with WatchWithdrawal")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchWithdrawal")
				return nil
			}
		}
	}), nil
}
