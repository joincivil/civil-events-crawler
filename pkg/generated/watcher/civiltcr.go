// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2019-12-13 04:40:45.16338 +0000 UTC
package watcher

import (
	// "fmt"
	"context"
	"time"

	"github.com/davecgh/go-spew/spew"
	log "github.com/golang/glog"
	"github.com/pkg/errors"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"

	specs "github.com/joincivil/civil-events-crawler/pkg/contractspecs"
	"github.com/joincivil/civil-events-crawler/pkg/model"
	"github.com/joincivil/civil-events-crawler/pkg/utils"

	"github.com/joincivil/go-common/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"

	"math/big"
)

func NewCivilTCRContractWatchers(contractAddress common.Address) *CivilTCRContractWatchers {
	return &CivilTCRContractWatchers{
		contractAddress: contractAddress,
	}
}

type CivilTCRContractWatchers struct {
	errors          chan error
	contractAddress common.Address
	contract        *contract.CivilTCRContract
	activeSubs      []utils.WatcherSubscription
}

func (w *CivilTCRContractWatchers) ContractAddress() common.Address {
	return w.contractAddress
}

func (w *CivilTCRContractWatchers) ContractName() string {
	return "CivilTCRContract"
}

func (w *CivilTCRContractWatchers) cancelFunc(cancelFn context.CancelFunc, killCancel <-chan bool) {
}

func (w *CivilTCRContractWatchers) StopWatchers(unsub bool) error {
	if unsub {
		for _, sub := range w.activeSubs {
			sub.Unsubscribe()
		}
	}
	w.activeSubs = nil
	w.contract = nil
	return nil
}

func (w *CivilTCRContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event, errs chan error) ([]utils.WatcherSubscription, error) {
	return w.StartCivilTCRContractWatchers(client, eventRecvChan, errs)
}

// StartCivilTCRContractWatchers starts up the event watchers for CivilTCRContract
func (w *CivilTCRContractWatchers) StartCivilTCRContractWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event, errs chan error) ([]utils.WatcherSubscription, error) {
	w.errors = errs
	contract, err := contract.NewCivilTCRContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilTCRContract: err: %v", err)
		return nil, errors.Wrap(err, "error initializing StartCivilTCRContract")
	}
	w.contract = contract

	var sub utils.WatcherSubscription
	subs := []utils.WatcherSubscription{}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "AppealGranted") {
		sub, err = w.startWatchAppealGranted(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startAppealGranted")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "AppealRequested") {
		sub, err = w.startWatchAppealRequested(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startAppealRequested")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "Application") {
		sub, err = w.startWatchApplication(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startApplication")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "ApplicationRemoved") {
		sub, err = w.startWatchApplicationRemoved(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startApplicationRemoved")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "ApplicationWhitelisted") {
		sub, err = w.startWatchApplicationWhitelisted(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startApplicationWhitelisted")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "Challenge") {
		sub, err = w.startWatchChallenge(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startChallenge")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "ChallengeFailed") {
		sub, err = w.startWatchChallengeFailed(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startChallengeFailed")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "ChallengeSucceeded") {
		sub, err = w.startWatchChallengeSucceeded(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startChallengeSucceeded")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "Deposit") {
		sub, err = w.startWatchDeposit(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startDeposit")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "FailedChallengeOverturned") {
		sub, err = w.startWatchFailedChallengeOverturned(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startFailedChallengeOverturned")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "GovernmentTransfered") {
		sub, err = w.startWatchGovernmentTransfered(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startGovernmentTransfered")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "GrantedAppealChallenged") {
		sub, err = w.startWatchGrantedAppealChallenged(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startGrantedAppealChallenged")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "GrantedAppealConfirmed") {
		sub, err = w.startWatchGrantedAppealConfirmed(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startGrantedAppealConfirmed")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "GrantedAppealOverturned") {
		sub, err = w.startWatchGrantedAppealOverturned(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startGrantedAppealOverturned")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "ListingRemoved") {
		sub, err = w.startWatchListingRemoved(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startListingRemoved")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "ListingWithdrawn") {
		sub, err = w.startWatchListingWithdrawn(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startListingWithdrawn")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "RewardClaimed") {
		sub, err = w.startWatchRewardClaimed(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startRewardClaimed")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "SuccessfulChallengeOverturned") {
		sub, err = w.startWatchSuccessfulChallengeOverturned(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startSuccessfulChallengeOverturned")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "TouchAndRemoved") {
		sub, err = w.startWatchTouchAndRemoved(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startTouchAndRemoved")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("CivilTCRContract", "Withdrawal") {
		sub, err = w.startWatchWithdrawal(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startWithdrawal")
		}
		subs = append(subs, sub)
	}

	w.activeSubs = subs
	return subs, nil
}

func (w *CivilTCRContractWatchers) startWatchAppealGranted(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchAppealGranted", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractAppealGranted, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchAppealGranted start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractAppealGranted)
			log.Infof("startupFn: Starting WatchAppealGranted: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchAppealGranted(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchAppealGranted: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchAppealGranted")
			}
			log.Infof("startupFn: WatchAppealGranted started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchAppealGranted: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchAppealGranted: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchAppealGranted: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchAppealGranted")
				}
				modelEvent, err := model.NewEventFromContractEvent("AppealGranted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchAppealGranted: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchAppealGranted")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchAppealGranted: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchAppealGranted")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchAppealGranted (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchAppealGranted: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchAppealGranted")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchAppealGranted: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchAppealRequested(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchAppealRequested", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractAppealRequested, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchAppealRequested start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractAppealRequested)
			log.Infof("startupFn: Starting WatchAppealRequested: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchAppealRequested(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchAppealRequested: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchAppealRequested")
			}
			log.Infof("startupFn: WatchAppealRequested started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchAppealRequested: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchAppealRequested: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchAppealRequested: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchAppealRequested")
				}
				modelEvent, err := model.NewEventFromContractEvent("AppealRequested", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchAppealRequested: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchAppealRequested")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchAppealRequested: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchAppealRequested")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchAppealRequested (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchAppealRequested: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchAppealRequested")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchAppealRequested: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplication(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchApplication", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractApplication, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchApplication start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractApplication)
			log.Infof("startupFn: Starting WatchApplication: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchApplication(
				opts,
				recvChan,
				[]common.Address{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchApplication: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchApplication")
			}
			log.Infof("startupFn: WatchApplication started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplication: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchApplication: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchApplication: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchApplication")
				}
				modelEvent, err := model.NewEventFromContractEvent("Application", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchApplication: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchApplication")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchApplication: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchApplication")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchApplication (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchApplication: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchApplication")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchApplication: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplicationRemoved(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchApplicationRemoved", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractApplicationRemoved, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchApplicationRemoved start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractApplicationRemoved)
			log.Infof("startupFn: Starting WatchApplicationRemoved: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchApplicationRemoved(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchApplicationRemoved: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchApplicationRemoved")
			}
			log.Infof("startupFn: WatchApplicationRemoved started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplicationRemoved: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchApplicationRemoved: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchApplicationRemoved: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchApplicationRemoved")
				}
				modelEvent, err := model.NewEventFromContractEvent("ApplicationRemoved", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchApplicationRemoved: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchApplicationRemoved")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchApplicationRemoved: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchApplicationRemoved")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchApplicationRemoved (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchApplicationRemoved: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchApplicationRemoved")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchApplicationRemoved: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchApplicationWhitelisted(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchApplicationWhitelisted", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractApplicationWhitelisted, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchApplicationWhitelisted start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractApplicationWhitelisted)
			log.Infof("startupFn: Starting WatchApplicationWhitelisted: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchApplicationWhitelisted(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchApplicationWhitelisted: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchApplicationWhitelisted")
			}
			log.Infof("startupFn: WatchApplicationWhitelisted started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchApplicationWhitelisted: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchApplicationWhitelisted: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchApplicationWhitelisted: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchApplicationWhitelisted")
				}
				modelEvent, err := model.NewEventFromContractEvent("ApplicationWhitelisted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchApplicationWhitelisted: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchApplicationWhitelisted")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchApplicationWhitelisted: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchApplicationWhitelisted")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchApplicationWhitelisted (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchApplicationWhitelisted: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchApplicationWhitelisted")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchApplicationWhitelisted: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallenge(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchChallenge", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractChallenge, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchChallenge start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractChallenge)
			log.Infof("startupFn: Starting WatchChallenge: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchChallenge(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchChallenge: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchChallenge")
			}
			log.Infof("startupFn: WatchChallenge started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallenge: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchChallenge: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallenge: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallenge")
				}
				modelEvent, err := model.NewEventFromContractEvent("Challenge", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchChallenge: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchChallenge")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallenge: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchChallenge")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchChallenge (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallenge: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchChallenge")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchChallenge: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallengeFailed(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchChallengeFailed", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractChallengeFailed, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchChallengeFailed start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractChallengeFailed)
			log.Infof("startupFn: Starting WatchChallengeFailed: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchChallengeFailed(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchChallengeFailed: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchChallengeFailed")
			}
			log.Infof("startupFn: WatchChallengeFailed started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeFailed: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchChallengeFailed: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallengeFailed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallengeFailed")
				}
				modelEvent, err := model.NewEventFromContractEvent("ChallengeFailed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchChallengeFailed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchChallengeFailed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallengeFailed: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchChallengeFailed")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchChallengeFailed (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallengeFailed: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchChallengeFailed")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchChallengeFailed: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchChallengeSucceeded(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchChallengeSucceeded", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractChallengeSucceeded, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchChallengeSucceeded start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractChallengeSucceeded)
			log.Infof("startupFn: Starting WatchChallengeSucceeded: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchChallengeSucceeded(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchChallengeSucceeded: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchChallengeSucceeded")
			}
			log.Infof("startupFn: WatchChallengeSucceeded started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeSucceeded: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchChallengeSucceeded: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallengeSucceeded: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallengeSucceeded")
				}
				modelEvent, err := model.NewEventFromContractEvent("ChallengeSucceeded", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchChallengeSucceeded: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchChallengeSucceeded")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallengeSucceeded: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchChallengeSucceeded")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchChallengeSucceeded (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallengeSucceeded: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchChallengeSucceeded")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchChallengeSucceeded: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchDeposit(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchDeposit", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractDeposit, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchDeposit start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractDeposit)
			log.Infof("startupFn: Starting WatchDeposit: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchDeposit(
				opts,
				recvChan,
				[]common.Address{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchDeposit: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchDeposit")
			}
			log.Infof("startupFn: WatchDeposit started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchDeposit: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchDeposit: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchDeposit: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchDeposit")
				}
				modelEvent, err := model.NewEventFromContractEvent("Deposit", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchDeposit: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchDeposit")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchDeposit: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchDeposit")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchDeposit (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchDeposit: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchDeposit")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchDeposit: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchFailedChallengeOverturned(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchFailedChallengeOverturned", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractFailedChallengeOverturned, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchFailedChallengeOverturned start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractFailedChallengeOverturned)
			log.Infof("startupFn: Starting WatchFailedChallengeOverturned: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchFailedChallengeOverturned(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchFailedChallengeOverturned: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchFailedChallengeOverturned")
			}
			log.Infof("startupFn: WatchFailedChallengeOverturned started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchFailedChallengeOverturned: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchFailedChallengeOverturned: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchFailedChallengeOverturned: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchFailedChallengeOverturned")
				}
				modelEvent, err := model.NewEventFromContractEvent("FailedChallengeOverturned", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchFailedChallengeOverturned: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchFailedChallengeOverturned")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchFailedChallengeOverturned: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchFailedChallengeOverturned")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchFailedChallengeOverturned (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchFailedChallengeOverturned: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchFailedChallengeOverturned")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchFailedChallengeOverturned: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGovernmentTransfered(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchGovernmentTransfered", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractGovernmentTransfered, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchGovernmentTransfered start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractGovernmentTransfered)
			log.Infof("startupFn: Starting WatchGovernmentTransfered: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchGovernmentTransfered(
				opts,
				recvChan,
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchGovernmentTransfered: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchGovernmentTransfered")
			}
			log.Infof("startupFn: WatchGovernmentTransfered started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGovernmentTransfered: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchGovernmentTransfered: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGovernmentTransfered: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGovernmentTransfered")
				}
				modelEvent, err := model.NewEventFromContractEvent("GovernmentTransfered", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchGovernmentTransfered: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchGovernmentTransfered")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchGovernmentTransfered: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchGovernmentTransfered")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchGovernmentTransfered (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGovernmentTransfered: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchGovernmentTransfered")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchGovernmentTransfered: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealChallenged(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchGrantedAppealChallenged", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractGrantedAppealChallenged, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchGrantedAppealChallenged start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractGrantedAppealChallenged)
			log.Infof("startupFn: Starting WatchGrantedAppealChallenged: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchGrantedAppealChallenged(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchGrantedAppealChallenged: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchGrantedAppealChallenged")
			}
			log.Infof("startupFn: WatchGrantedAppealChallenged started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealChallenged: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchGrantedAppealChallenged: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGrantedAppealChallenged: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGrantedAppealChallenged")
				}
				modelEvent, err := model.NewEventFromContractEvent("GrantedAppealChallenged", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchGrantedAppealChallenged: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchGrantedAppealChallenged")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchGrantedAppealChallenged: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchGrantedAppealChallenged")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchGrantedAppealChallenged (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGrantedAppealChallenged: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchGrantedAppealChallenged")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchGrantedAppealChallenged: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealConfirmed(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchGrantedAppealConfirmed", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractGrantedAppealConfirmed, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchGrantedAppealConfirmed start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractGrantedAppealConfirmed)
			log.Infof("startupFn: Starting WatchGrantedAppealConfirmed: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchGrantedAppealConfirmed(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchGrantedAppealConfirmed: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchGrantedAppealConfirmed")
			}
			log.Infof("startupFn: WatchGrantedAppealConfirmed started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealConfirmed: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchGrantedAppealConfirmed: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGrantedAppealConfirmed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGrantedAppealConfirmed")
				}
				modelEvent, err := model.NewEventFromContractEvent("GrantedAppealConfirmed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchGrantedAppealConfirmed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchGrantedAppealConfirmed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchGrantedAppealConfirmed: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchGrantedAppealConfirmed")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchGrantedAppealConfirmed (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGrantedAppealConfirmed: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchGrantedAppealConfirmed")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchGrantedAppealConfirmed: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchGrantedAppealOverturned(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchGrantedAppealOverturned", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractGrantedAppealOverturned, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchGrantedAppealOverturned start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractGrantedAppealOverturned)
			log.Infof("startupFn: Starting WatchGrantedAppealOverturned: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchGrantedAppealOverturned(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchGrantedAppealOverturned: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchGrantedAppealOverturned")
			}
			log.Infof("startupFn: WatchGrantedAppealOverturned started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchGrantedAppealOverturned: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchGrantedAppealOverturned: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchGrantedAppealOverturned: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchGrantedAppealOverturned")
				}
				modelEvent, err := model.NewEventFromContractEvent("GrantedAppealOverturned", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchGrantedAppealOverturned: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchGrantedAppealOverturned")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchGrantedAppealOverturned: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchGrantedAppealOverturned")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchGrantedAppealOverturned (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchGrantedAppealOverturned: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchGrantedAppealOverturned")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchGrantedAppealOverturned: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchListingRemoved(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchListingRemoved", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractListingRemoved, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchListingRemoved start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractListingRemoved)
			log.Infof("startupFn: Starting WatchListingRemoved: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchListingRemoved(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchListingRemoved: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchListingRemoved")
			}
			log.Infof("startupFn: WatchListingRemoved started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchListingRemoved: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchListingRemoved: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchListingRemoved: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchListingRemoved")
				}
				modelEvent, err := model.NewEventFromContractEvent("ListingRemoved", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchListingRemoved: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchListingRemoved")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchListingRemoved: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchListingRemoved")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchListingRemoved (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchListingRemoved: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchListingRemoved")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchListingRemoved: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchListingWithdrawn(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchListingWithdrawn", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractListingWithdrawn, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchListingWithdrawn start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractListingWithdrawn)
			log.Infof("startupFn: Starting WatchListingWithdrawn: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchListingWithdrawn(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchListingWithdrawn: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchListingWithdrawn")
			}
			log.Infof("startupFn: WatchListingWithdrawn started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchListingWithdrawn: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchListingWithdrawn: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchListingWithdrawn: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchListingWithdrawn")
				}
				modelEvent, err := model.NewEventFromContractEvent("ListingWithdrawn", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchListingWithdrawn: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchListingWithdrawn")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchListingWithdrawn: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchListingWithdrawn")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchListingWithdrawn (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchListingWithdrawn: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchListingWithdrawn")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchListingWithdrawn: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchRewardClaimed(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchRewardClaimed", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractRewardClaimed, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchRewardClaimed start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractRewardClaimed)
			log.Infof("startupFn: Starting WatchRewardClaimed: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchRewardClaimed(
				opts,
				recvChan,
				[]*big.Int{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchRewardClaimed: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchRewardClaimed")
			}
			log.Infof("startupFn: WatchRewardClaimed started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchRewardClaimed: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchRewardClaimed: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchRewardClaimed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchRewardClaimed")
				}
				modelEvent, err := model.NewEventFromContractEvent("RewardClaimed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchRewardClaimed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchRewardClaimed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchRewardClaimed: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchRewardClaimed")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchRewardClaimed (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchRewardClaimed: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchRewardClaimed")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchRewardClaimed: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchSuccessfulChallengeOverturned(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchSuccessfulChallengeOverturned", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractSuccessfulChallengeOverturned, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchSuccessfulChallengeOverturned start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractSuccessfulChallengeOverturned)
			log.Infof("startupFn: Starting WatchSuccessfulChallengeOverturned: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchSuccessfulChallengeOverturned(
				opts,
				recvChan,
				[]common.Address{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchSuccessfulChallengeOverturned: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchSuccessfulChallengeOverturned")
			}
			log.Infof("startupFn: WatchSuccessfulChallengeOverturned started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchSuccessfulChallengeOverturned: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchSuccessfulChallengeOverturned: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchSuccessfulChallengeOverturned: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchSuccessfulChallengeOverturned")
				}
				modelEvent, err := model.NewEventFromContractEvent("SuccessfulChallengeOverturned", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchSuccessfulChallengeOverturned: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchSuccessfulChallengeOverturned")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchSuccessfulChallengeOverturned: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchSuccessfulChallengeOverturned")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchSuccessfulChallengeOverturned (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchSuccessfulChallengeOverturned: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchSuccessfulChallengeOverturned")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchSuccessfulChallengeOverturned: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchTouchAndRemoved(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchTouchAndRemoved", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractTouchAndRemoved, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchTouchAndRemoved start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractTouchAndRemoved)
			log.Infof("startupFn: Starting WatchTouchAndRemoved: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchTouchAndRemoved(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchTouchAndRemoved: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchTouchAndRemoved")
			}
			log.Infof("startupFn: WatchTouchAndRemoved started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchTouchAndRemoved: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchTouchAndRemoved: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchTouchAndRemoved: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchTouchAndRemoved")
				}
				modelEvent, err := model.NewEventFromContractEvent("TouchAndRemoved", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchTouchAndRemoved: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchTouchAndRemoved")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchTouchAndRemoved: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchTouchAndRemoved")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchTouchAndRemoved (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchTouchAndRemoved: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchTouchAndRemoved")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchTouchAndRemoved: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *CivilTCRContractWatchers) startWatchWithdrawal(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchWithdrawal", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.CivilTCRContractWithdrawal, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan bool)
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan bool) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchWithdrawal start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.CivilTCRContractWithdrawal)
			log.Infof("startupFn: Starting WatchWithdrawal: addr: %v", w.contractAddress.Hex())
			sub, err := w.contract.WatchWithdrawal(
				opts,
				recvChan,
				[]common.Address{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchWithdrawal: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchWithdrawal")
			}
			log.Infof("startupFn: WatchWithdrawal started: addr: %v", w.contractAddress.Hex())
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchWithdrawal: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchWithdrawal: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchWithdrawal: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchWithdrawal")
				}
				modelEvent, err := model.NewEventFromContractEvent("Withdrawal", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchWithdrawal: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchWithdrawal")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchWithdrawal: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchWithdrawal")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchWithdrawal (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchWithdrawal: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchWithdrawal")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchWithdrawal: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}
