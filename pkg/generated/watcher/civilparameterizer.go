// Code generated by 'gen/watchergen'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'listener/watchergen' for more details
// File was generated at 2020-02-18 16:45:06.50452 +0000 UTC
package watcher

import (
	// "fmt"
	"context"
	"time"

	"github.com/davecgh/go-spew/spew"
	log "github.com/golang/glog"
	"github.com/pkg/errors"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"

	specs "github.com/joincivil/civil-events-crawler/pkg/contractspecs"
	"github.com/joincivil/civil-events-crawler/pkg/model"
	"github.com/joincivil/civil-events-crawler/pkg/utils"

	"github.com/joincivil/go-common/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"

	"math/big"
)

func NewParameterizerContractWatchers(contractAddress common.Address) *ParameterizerContractWatchers {
	return &ParameterizerContractWatchers{
		contractAddress: contractAddress,
	}
}

type ParameterizerContractWatchers struct {
	errors          chan error
	contractAddress common.Address
	contract        *contract.ParameterizerContract
	activeSubs      []utils.WatcherSubscription
}

func (w *ParameterizerContractWatchers) ContractAddress() common.Address {
	return w.contractAddress
}

func (w *ParameterizerContractWatchers) ContractName() string {
	return "ParameterizerContract"
}

func (w *ParameterizerContractWatchers) cancelFunc(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
}

func (w *ParameterizerContractWatchers) StopWatchers(unsub bool) error {
	if unsub {
		for _, sub := range w.activeSubs {
			sub.Unsubscribe()
		}
	}
	w.activeSubs = nil
	w.contract = nil
	return nil
}

func (w *ParameterizerContractWatchers) StartWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event, errs chan error) ([]utils.WatcherSubscription, error) {
	return w.StartParameterizerContractWatchers(client, eventRecvChan, errs)
}

// StartParameterizerContractWatchers starts up the event watchers for ParameterizerContract
func (w *ParameterizerContractWatchers) StartParameterizerContractWatchers(client bind.ContractBackend,
	eventRecvChan chan *model.Event, errs chan error) ([]utils.WatcherSubscription, error) {
	w.errors = errs
	contract, err := contract.NewParameterizerContract(w.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartParameterizerContract: err: %v", err)
		return nil, errors.Wrap(err, "error initializing StartParameterizerContract")
	}
	w.contract = contract

	var sub utils.WatcherSubscription
	subs := []utils.WatcherSubscription{}

	if specs.IsListenerEnabledForEvent("ParameterizerContract", "ChallengeFailed") {
		sub, err = w.startWatchChallengeFailed(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startChallengeFailed")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("ParameterizerContract", "ChallengeSucceeded") {
		sub, err = w.startWatchChallengeSucceeded(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startChallengeSucceeded")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("ParameterizerContract", "NewChallenge") {
		sub, err = w.startWatchNewChallenge(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startNewChallenge")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("ParameterizerContract", "ProposalAccepted") {
		sub, err = w.startWatchProposalAccepted(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startProposalAccepted")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("ParameterizerContract", "ProposalExpired") {
		sub, err = w.startWatchProposalExpired(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startProposalExpired")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("ParameterizerContract", "ReparameterizationProposal") {
		sub, err = w.startWatchReparameterizationProposal(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startReparameterizationProposal")
		}
		subs = append(subs, sub)
	}

	if specs.IsListenerEnabledForEvent("ParameterizerContract", "RewardClaimed") {
		sub, err = w.startWatchRewardClaimed(eventRecvChan)
		if err != nil {
			return nil, errors.WithMessage(err, "error starting startRewardClaimed")
		}
		subs = append(subs, sub)
	}

	w.activeSubs = subs
	return subs, nil
}

func (w *ParameterizerContractWatchers) startWatchChallengeFailed(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchChallengeFailed", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.ParameterizerContractChallengeFailed, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchChallengeFailed start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.ParameterizerContractChallengeFailed)
			sub, err := w.contract.WatchChallengeFailed(
				opts,
				recvChan,
				[][32]byte{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchChallengeFailed: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchChallengeFailed")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeFailed: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchChallengeFailed: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallengeFailed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallengeFailed")
				}
				modelEvent, err := model.NewEventFromContractEvent("ChallengeFailed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchChallengeFailed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchChallengeFailed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallengeFailed: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchChallengeFailed")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchChallengeFailed (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallengeFailed: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchChallengeFailed")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchChallengeFailed: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchChallengeSucceeded(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchChallengeSucceeded", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.ParameterizerContractChallengeSucceeded, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchChallengeSucceeded start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.ParameterizerContractChallengeSucceeded)
			sub, err := w.contract.WatchChallengeSucceeded(
				opts,
				recvChan,
				[][32]byte{},
				[]*big.Int{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchChallengeSucceeded: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchChallengeSucceeded")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchChallengeSucceeded: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchChallengeSucceeded: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchChallengeSucceeded: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchChallengeSucceeded")
				}
				modelEvent, err := model.NewEventFromContractEvent("ChallengeSucceeded", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchChallengeSucceeded: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchChallengeSucceeded")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchChallengeSucceeded: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchChallengeSucceeded")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchChallengeSucceeded (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchChallengeSucceeded: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchChallengeSucceeded")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchChallengeSucceeded: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchNewChallenge(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchNewChallenge", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.ParameterizerContractNewChallenge, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchNewChallenge start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.ParameterizerContractNewChallenge)
			sub, err := w.contract.WatchNewChallenge(
				opts,
				recvChan,
				[][32]byte{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchNewChallenge: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchNewChallenge")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchNewChallenge: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchNewChallenge: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchNewChallenge: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchNewChallenge")
				}
				modelEvent, err := model.NewEventFromContractEvent("NewChallenge", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchNewChallenge: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchNewChallenge")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchNewChallenge: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchNewChallenge")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchNewChallenge (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchNewChallenge: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchNewChallenge")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchNewChallenge: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchProposalAccepted(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchProposalAccepted", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.ParameterizerContractProposalAccepted, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchProposalAccepted start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.ParameterizerContractProposalAccepted)
			sub, err := w.contract.WatchProposalAccepted(
				opts,
				recvChan,
				[][32]byte{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchProposalAccepted: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchProposalAccepted")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchProposalAccepted: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchProposalAccepted: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchProposalAccepted: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchProposalAccepted")
				}
				modelEvent, err := model.NewEventFromContractEvent("ProposalAccepted", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchProposalAccepted: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchProposalAccepted")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchProposalAccepted: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchProposalAccepted")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchProposalAccepted (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchProposalAccepted: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchProposalAccepted")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchProposalAccepted: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchProposalExpired(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchProposalExpired", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.ParameterizerContractProposalExpired, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchProposalExpired start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.ParameterizerContractProposalExpired)
			sub, err := w.contract.WatchProposalExpired(
				opts,
				recvChan,
				[][32]byte{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchProposalExpired: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchProposalExpired")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchProposalExpired: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchProposalExpired: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchProposalExpired: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchProposalExpired")
				}
				modelEvent, err := model.NewEventFromContractEvent("ProposalExpired", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchProposalExpired: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchProposalExpired")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchProposalExpired: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchProposalExpired")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchProposalExpired (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchProposalExpired: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchProposalExpired")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchProposalExpired: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchReparameterizationProposal(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchReparameterizationProposal", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.ParameterizerContractReparameterizationProposal, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchReparameterizationProposal start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.ParameterizerContractReparameterizationProposal)
			sub, err := w.contract.WatchReparameterizationProposal(
				opts,
				recvChan,
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchReparameterizationProposal: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchReparameterizationProposal")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchReparameterizationProposal: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchReparameterizationProposal: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchReparameterizationProposal: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchReparameterizationProposal")
				}
				modelEvent, err := model.NewEventFromContractEvent("ReparameterizationProposal", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchReparameterizationProposal: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchReparameterizationProposal")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchReparameterizationProposal: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchReparameterizationProposal")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchReparameterizationProposal (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchReparameterizationProposal: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchReparameterizationProposal")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchReparameterizationProposal: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}

func (w *ParameterizerContractWatchers) startWatchRewardClaimed(eventRecvChan chan *model.Event) (utils.WatcherSubscription, error) {
	killCancelTimeoutSecs := 10
	return utils.NewWatcherSubscription("WatchRewardClaimed", func(quit <-chan struct{}) error {
		startupFn := func() (utils.WatcherSubscription, chan *contract.ParameterizerContractRewardClaimed, error) {
			ctx := context.Background()
			ctx, cancelFn := context.WithCancel(ctx)
			opts := &bind.WatchOpts{Context: ctx}
			killCancel := make(chan struct{})
			// 10 sec timeout mechanism for starting up watcher
			go func(cancelFn context.CancelFunc, killCancel <-chan struct{}) {
				select {
				case <-time.After(time.Duration(killCancelTimeoutSecs) * time.Second):
					log.Errorf("WatchRewardClaimed start timeout, cancelling...")
					cancelFn()
				case <-killCancel:
				}
			}(cancelFn, killCancel)
			recvChan := make(chan *contract.ParameterizerContractRewardClaimed)
			sub, err := w.contract.WatchRewardClaimed(
				opts,
				recvChan,
				[]*big.Int{},
				[]common.Address{},
			)
			close(killCancel)
			if err != nil {
				if sub != nil {
					log.Infof("startupFn: Unsubscribing WatchRewardClaimed: addr: %v", w.contractAddress.Hex())
					sub.Unsubscribe()
					sub = nil
				}
				return nil, nil, errors.Wrap(err, "startupFn: error starting WatchRewardClaimed")
			}
			return sub, recvChan, nil
		}
		sub, recvChan, err := startupFn()
		if err != nil {
			log.Errorf("Error starting WatchRewardClaimed: addr: %v, %v", w.contractAddress.Hex(), err)
			if sub != nil {
				sub.Unsubscribe()
				close(recvChan)
				sub = nil
			}
			w.errors <- err
			return err
		}
		defer func() {
			sub.Unsubscribe()
			close(recvChan)
			sub = nil
		}()
		log.Infof("Starting up WatchRewardClaimed: addr: %v", w.contractAddress.Hex())
		for {
			select {
			case event := <-recvChan:
				if log.V(2) {
					log.Infof("Received event on WatchRewardClaimed: %v", spew.Sprintf("%#+v", event))
				} else {
					log.Info("Received event on WatchRewardClaimed")
				}
				modelEvent, err := model.NewEventFromContractEvent("RewardClaimed", w.ContractName(), w.contractAddress, event, ctime.CurrentEpochSecsInInt64(), model.Watcher)
				if err != nil {
					log.Errorf("Error creating new event: event: %v, err: %v", event, err)
					continue
				}
				select {
				case eventRecvChan <- modelEvent:
					if log.V(2) {
						log.Infof("Sent event to eventRecvChan on WatchRewardClaimed: %v", spew.Sprintf("%#+v", event))
					} else {
						log.Info("Sent event to eventRecvChan on WatchRewardClaimed")
					}
				case err := <-sub.Err():
					log.Errorf("Error with WatchRewardClaimed: addr: %v, fatal (a): %v", w.contractAddress.Hex(), err)
					err = errors.Wrap(err, "error with WatchRewardClaimed")
					w.errors <- err
					return err
				case <-quit:
					log.Infof("Quit WatchRewardClaimed (a): addr: %v", w.contractAddress.Hex())
					return nil
				}
			case err := <-sub.Err():
				log.Errorf("Error with WatchRewardClaimed: addr: %v, fatal (b): %v", w.contractAddress.Hex(), err)
				err = errors.Wrap(err, "error with WatchRewardClaimed")
				w.errors <- err
				return err
			case <-quit:
				log.Infof("Quitting loop for WatchRewardClaimed: addr: %v", w.contractAddress.Hex())
				return nil
			}
		}
	}), nil
}
