// Code generated by 'gen/eventhandlergen.go'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'gen/filterergen_template.go' for more details
// File was generated at 2019-12-05 18:14:29.749899 +0000 UTC
package filterer

import (
	log "github.com/golang/glog"
	"runtime"
	"sync"

	"github.com/Jeffail/tunny"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"

	specs "github.com/joincivil/civil-events-crawler/pkg/contractspecs"
	commongen "github.com/joincivil/civil-events-crawler/pkg/generated/common"
	"github.com/joincivil/civil-events-crawler/pkg/model"

	"github.com/joincivil/go-common/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"

	"math/big"
)

func NewCivilTCRContractFilterers(contractAddress common.Address) *CivilTCRContractFilterers {
	contractFilterers := &CivilTCRContractFilterers{
		contractAddress:   contractAddress,
		eventTypes:        commongen.EventTypesCivilTCRContract(),
		eventToStartBlock: make(map[string]uint64),
		lastEvents:        make([]*model.Event, 0),
	}
	for _, eventType := range contractFilterers.eventTypes {
		contractFilterers.eventToStartBlock[eventType] = 0
	}
	return contractFilterers
}

type CivilTCRContractFilterers struct {
	contractAddress   common.Address
	contract          *contract.CivilTCRContract
	eventTypes        []string
	eventToStartBlock map[string]uint64
	lastEvents        []*model.Event
	lastEventsMutex   sync.Mutex
	pastEventsMutex   sync.Mutex
}

func (f *CivilTCRContractFilterers) ContractName() string {
	return "CivilTCRContract"
}

func (f *CivilTCRContractFilterers) ContractAddress() common.Address {
	return f.contractAddress
}

func (f *CivilTCRContractFilterers) StartFilterers(client bind.ContractBackend, pastEvents []*model.Event) (error, []*model.Event) {
	return f.StartCivilTCRContractFilterers(client, pastEvents)
}

func (f *CivilTCRContractFilterers) EventTypes() []string {
	return f.eventTypes
}

func (f *CivilTCRContractFilterers) UpdateStartBlock(eventType string, startBlock uint64) {
	f.eventToStartBlock[eventType] = startBlock
}

func (f *CivilTCRContractFilterers) LastEvents() []*model.Event {
	return f.lastEvents
}

// StartCivilTCRContractFilterers retrieves events for CivilTCRContract
func (f *CivilTCRContractFilterers) StartCivilTCRContractFilterers(client bind.ContractBackend, pastEvents []*model.Event) (error, []*model.Event) {
	contract, err := contract.NewCivilTCRContract(f.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartCivilTCRContract: err: %v", err)
		return err, pastEvents
	}
	f.contract = contract

	workerMultiplier := 1
	numWorkers := runtime.NumCPU() * workerMultiplier
	log.Infof("Num of workers: %v", numWorkers)
	pool := tunny.NewFunc(numWorkers, func(payload interface{}) interface{} {
		f := payload.(func())
		f()
		return nil
	})
	defer pool.Close()

	wg := sync.WaitGroup{}
	resultsChan := make(chan []*model.Event)
	done := make(chan bool)

	if !specs.IsEventDisabled("CivilTCRContract", "AppealGranted") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["AppealGranted"]
				e, pevents := f.startFilterAppealGranted(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving AppealGranted: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "AppealRequested") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["AppealRequested"]
				e, pevents := f.startFilterAppealRequested(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving AppealRequested: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "Application") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["Application"]
				e, pevents := f.startFilterApplication(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving Application: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "ApplicationRemoved") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["ApplicationRemoved"]
				e, pevents := f.startFilterApplicationRemoved(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving ApplicationRemoved: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "ApplicationWhitelisted") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["ApplicationWhitelisted"]
				e, pevents := f.startFilterApplicationWhitelisted(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving ApplicationWhitelisted: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "Challenge") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["Challenge"]
				e, pevents := f.startFilterChallenge(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving Challenge: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "ChallengeFailed") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["ChallengeFailed"]
				e, pevents := f.startFilterChallengeFailed(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving ChallengeFailed: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "ChallengeSucceeded") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["ChallengeSucceeded"]
				e, pevents := f.startFilterChallengeSucceeded(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving ChallengeSucceeded: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "Deposit") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["Deposit"]
				e, pevents := f.startFilterDeposit(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving Deposit: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "FailedChallengeOverturned") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["FailedChallengeOverturned"]
				e, pevents := f.startFilterFailedChallengeOverturned(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving FailedChallengeOverturned: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "GovernmentTransfered") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["GovernmentTransfered"]
				e, pevents := f.startFilterGovernmentTransfered(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving GovernmentTransfered: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "GrantedAppealChallenged") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["GrantedAppealChallenged"]
				e, pevents := f.startFilterGrantedAppealChallenged(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving GrantedAppealChallenged: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "GrantedAppealConfirmed") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["GrantedAppealConfirmed"]
				e, pevents := f.startFilterGrantedAppealConfirmed(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving GrantedAppealConfirmed: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "GrantedAppealOverturned") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["GrantedAppealOverturned"]
				e, pevents := f.startFilterGrantedAppealOverturned(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving GrantedAppealOverturned: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "ListingRemoved") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["ListingRemoved"]
				e, pevents := f.startFilterListingRemoved(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving ListingRemoved: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "ListingWithdrawn") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["ListingWithdrawn"]
				e, pevents := f.startFilterListingWithdrawn(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving ListingWithdrawn: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "RewardClaimed") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["RewardClaimed"]
				e, pevents := f.startFilterRewardClaimed(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving RewardClaimed: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "SuccessfulChallengeOverturned") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["SuccessfulChallengeOverturned"]
				e, pevents := f.startFilterSuccessfulChallengeOverturned(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving SuccessfulChallengeOverturned: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "TouchAndRemoved") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["TouchAndRemoved"]
				e, pevents := f.startFilterTouchAndRemoved(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving TouchAndRemoved: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	if !specs.IsEventDisabled("CivilTCRContract", "Withdrawal") {
		wg.Add(1)
		go func() {
			filterFunc := func() {
				startBlock := f.eventToStartBlock["Withdrawal"]
				e, pevents := f.startFilterWithdrawal(startBlock, []*model.Event{})
				if e != nil {
					log.Errorf("Error retrieving Withdrawal: err: %v", e)
					return
				}
				if len(pevents) > 0 {
					f.lastEventsMutex.Lock()
					f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
					f.lastEventsMutex.Unlock()
					resultsChan <- pevents
				}
			}
			pool.Process(filterFunc)
			wg.Done()
		}()
	}

	go func() {
		wg.Wait()
		done <- true
		log.Info("Filtering routines complete")
	}()

Loop:
	for {
		select {
		case <-done:
			break Loop
		case pevents := <-resultsChan:
			f.pastEventsMutex.Lock()
			pastEvents = append(pastEvents, pevents...)
			f.pastEventsMutex.Unlock()
		}
	}
	log.Infof("Total events found: %v", len(pastEvents))
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterAppealGranted(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for AppealGranted for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractAppealGrantedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterAppealGranted(
			opts,
			[]common.Address{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: AppealGranted for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: AppealGranted for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: AppealGranted for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("AppealGranted", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("AppealGranted events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterAppealRequested(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for AppealRequested for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractAppealRequestedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterAppealRequested(
			opts,
			[]common.Address{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: AppealRequested for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: AppealRequested for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: AppealRequested for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("AppealRequested", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("AppealRequested events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterApplication(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for Application for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractApplicationIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterApplication(
			opts,
			[]common.Address{},
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: Application for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: Application for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: Application for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("Application", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("Application events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterApplicationRemoved(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for ApplicationRemoved for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractApplicationRemovedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterApplicationRemoved(
			opts,
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: ApplicationRemoved for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: ApplicationRemoved for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: ApplicationRemoved for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("ApplicationRemoved", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("ApplicationRemoved events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterApplicationWhitelisted(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for ApplicationWhitelisted for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractApplicationWhitelistedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterApplicationWhitelisted(
			opts,
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: ApplicationWhitelisted for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: ApplicationWhitelisted for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: ApplicationWhitelisted for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("ApplicationWhitelisted", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("ApplicationWhitelisted events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterChallenge(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for Challenge for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractChallengeIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterChallenge(
			opts,
			[]common.Address{},
			[]*big.Int{},
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: Challenge for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: Challenge for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: Challenge for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("Challenge", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("Challenge events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterChallengeFailed(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for ChallengeFailed for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractChallengeFailedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterChallengeFailed(
			opts,
			[]common.Address{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: ChallengeFailed for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: ChallengeFailed for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: ChallengeFailed for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("ChallengeFailed", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("ChallengeFailed events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterChallengeSucceeded(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for ChallengeSucceeded for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractChallengeSucceededIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterChallengeSucceeded(
			opts,
			[]common.Address{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: ChallengeSucceeded for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: ChallengeSucceeded for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: ChallengeSucceeded for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("ChallengeSucceeded", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("ChallengeSucceeded events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterDeposit(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for Deposit for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractDepositIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterDeposit(
			opts,
			[]common.Address{},
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: Deposit for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: Deposit for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: Deposit for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("Deposit", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("Deposit events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterFailedChallengeOverturned(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for FailedChallengeOverturned for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractFailedChallengeOverturnedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterFailedChallengeOverturned(
			opts,
			[]common.Address{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: FailedChallengeOverturned for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: FailedChallengeOverturned for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: FailedChallengeOverturned for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("FailedChallengeOverturned", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("FailedChallengeOverturned events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterGovernmentTransfered(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for GovernmentTransfered for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractGovernmentTransferedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterGovernmentTransfered(
			opts,
		)
		if err == nil {
			log.Infof("Successful filter: GovernmentTransfered for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: GovernmentTransfered for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: GovernmentTransfered for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("GovernmentTransfered", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("GovernmentTransfered events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterGrantedAppealChallenged(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for GrantedAppealChallenged for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractGrantedAppealChallengedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterGrantedAppealChallenged(
			opts,
			[]common.Address{},
			[]*big.Int{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: GrantedAppealChallenged for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: GrantedAppealChallenged for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: GrantedAppealChallenged for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("GrantedAppealChallenged", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("GrantedAppealChallenged events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterGrantedAppealConfirmed(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for GrantedAppealConfirmed for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractGrantedAppealConfirmedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterGrantedAppealConfirmed(
			opts,
			[]common.Address{},
			[]*big.Int{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: GrantedAppealConfirmed for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: GrantedAppealConfirmed for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: GrantedAppealConfirmed for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("GrantedAppealConfirmed", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("GrantedAppealConfirmed events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterGrantedAppealOverturned(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for GrantedAppealOverturned for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractGrantedAppealOverturnedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterGrantedAppealOverturned(
			opts,
			[]common.Address{},
			[]*big.Int{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: GrantedAppealOverturned for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: GrantedAppealOverturned for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: GrantedAppealOverturned for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("GrantedAppealOverturned", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("GrantedAppealOverturned events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterListingRemoved(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for ListingRemoved for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractListingRemovedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterListingRemoved(
			opts,
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: ListingRemoved for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: ListingRemoved for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: ListingRemoved for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("ListingRemoved", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("ListingRemoved events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterListingWithdrawn(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for ListingWithdrawn for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractListingWithdrawnIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterListingWithdrawn(
			opts,
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: ListingWithdrawn for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: ListingWithdrawn for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: ListingWithdrawn for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("ListingWithdrawn", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("ListingWithdrawn events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterRewardClaimed(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for RewardClaimed for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractRewardClaimedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterRewardClaimed(
			opts,
			[]*big.Int{},
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: RewardClaimed for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: RewardClaimed for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: RewardClaimed for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("RewardClaimed", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("RewardClaimed events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterSuccessfulChallengeOverturned(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for SuccessfulChallengeOverturned for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractSuccessfulChallengeOverturnedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterSuccessfulChallengeOverturned(
			opts,
			[]common.Address{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: SuccessfulChallengeOverturned for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: SuccessfulChallengeOverturned for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: SuccessfulChallengeOverturned for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("SuccessfulChallengeOverturned", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("SuccessfulChallengeOverturned events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterTouchAndRemoved(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for TouchAndRemoved for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractTouchAndRemovedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterTouchAndRemoved(
			opts,
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: TouchAndRemoved for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: TouchAndRemoved for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: TouchAndRemoved for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("TouchAndRemoved", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("TouchAndRemoved events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *CivilTCRContractFilterers) startFilterWithdrawal(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for Withdrawal for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.CivilTCRContractWithdrawalIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterWithdrawal(
			opts,
			[]common.Address{},
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: Withdrawal for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: Withdrawal for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: Withdrawal for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("Withdrawal", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("Withdrawal events added: %v", numEventsAdded)
	return nil, pastEvents
}
