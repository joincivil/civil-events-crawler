// Code generated by 'gen/eventhandlergen.go'  DO NOT EDIT.
// IT SHOULD NOT BE EDITED BY HAND AS ANY CHANGES MAY BE OVERWRITTEN
// Please reference 'gen/filterergen_template.go' for more details
// File was generated at 2019-04-04 01:15:10.80008 +0000 UTC
package filterer

import (
	log "github.com/golang/glog"
	"runtime"
	"sync"

	"github.com/Jeffail/tunny"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"

	commongen "github.com/joincivil/civil-events-crawler/pkg/generated/common"
	"github.com/joincivil/civil-events-crawler/pkg/model"

	"github.com/joincivil/go-common/pkg/generated/contract"
	ctime "github.com/joincivil/go-common/pkg/time"

	"math/big"
)

func NewNewsroomContractFilterers(contractAddress common.Address) *NewsroomContractFilterers {
	contractFilterers := &NewsroomContractFilterers{
		contractAddress:   contractAddress,
		eventTypes:        commongen.EventTypesNewsroomContract(),
		eventToStartBlock: make(map[string]uint64),
		lastEvents:        make([]*model.Event, 0),
	}
	for _, eventType := range contractFilterers.eventTypes {
		contractFilterers.eventToStartBlock[eventType] = 0
	}
	return contractFilterers
}

type NewsroomContractFilterers struct {
	contractAddress   common.Address
	contract          *contract.NewsroomContract
	eventTypes        []string
	eventToStartBlock map[string]uint64
	lastEvents        []*model.Event
	lastEventsMutex   sync.Mutex
	pastEventsMutex   sync.Mutex
}

func (f *NewsroomContractFilterers) ContractName() string {
	return "NewsroomContract"
}

func (f *NewsroomContractFilterers) ContractAddress() common.Address {
	return f.contractAddress
}

func (f *NewsroomContractFilterers) StartFilterers(client bind.ContractBackend, pastEvents []*model.Event) (error, []*model.Event) {
	return f.StartNewsroomContractFilterers(client, pastEvents)
}

func (f *NewsroomContractFilterers) EventTypes() []string {
	return f.eventTypes
}

func (f *NewsroomContractFilterers) UpdateStartBlock(eventType string, startBlock uint64) {
	f.eventToStartBlock[eventType] = startBlock
}

func (f *NewsroomContractFilterers) LastEvents() []*model.Event {
	return f.lastEvents
}

// StartNewsroomContractFilterers retrieves events for NewsroomContract
func (f *NewsroomContractFilterers) StartNewsroomContractFilterers(client bind.ContractBackend, pastEvents []*model.Event) (error, []*model.Event) {
	contract, err := contract.NewNewsroomContract(f.contractAddress, client)
	if err != nil {
		log.Errorf("Error initializing StartNewsroomContract: err: %v", err)
		return err, pastEvents
	}
	f.contract = contract

	workerMultiplier := 1
	numWorkers := runtime.NumCPU() * workerMultiplier
	log.Infof("Num of workers: %v", numWorkers)
	pool := tunny.NewFunc(numWorkers, func(payload interface{}) interface{} {
		f := payload.(func())
		f()
		return nil
	})
	defer pool.Close()

	wg := sync.WaitGroup{}
	resultsChan := make(chan []*model.Event)
	done := make(chan bool)

	wg.Add(1)
	go func() {
		filterFunc := func() {
			startBlock := f.eventToStartBlock["ContentPublished"]
			e, pevents := f.startFilterContentPublished(startBlock, []*model.Event{})
			if e != nil {
				log.Errorf("Error retrieving ContentPublished: err: %v", e)
				return
			}
			if len(pevents) > 0 {
				f.lastEventsMutex.Lock()
				f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
				f.lastEventsMutex.Unlock()
				resultsChan <- pevents
			}
		}
		pool.Process(filterFunc)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		filterFunc := func() {
			startBlock := f.eventToStartBlock["NameChanged"]
			e, pevents := f.startFilterNameChanged(startBlock, []*model.Event{})
			if e != nil {
				log.Errorf("Error retrieving NameChanged: err: %v", e)
				return
			}
			if len(pevents) > 0 {
				f.lastEventsMutex.Lock()
				f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
				f.lastEventsMutex.Unlock()
				resultsChan <- pevents
			}
		}
		pool.Process(filterFunc)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		filterFunc := func() {
			startBlock := f.eventToStartBlock["OwnershipRenounced"]
			e, pevents := f.startFilterOwnershipRenounced(startBlock, []*model.Event{})
			if e != nil {
				log.Errorf("Error retrieving OwnershipRenounced: err: %v", e)
				return
			}
			if len(pevents) > 0 {
				f.lastEventsMutex.Lock()
				f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
				f.lastEventsMutex.Unlock()
				resultsChan <- pevents
			}
		}
		pool.Process(filterFunc)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		filterFunc := func() {
			startBlock := f.eventToStartBlock["OwnershipTransferred"]
			e, pevents := f.startFilterOwnershipTransferred(startBlock, []*model.Event{})
			if e != nil {
				log.Errorf("Error retrieving OwnershipTransferred: err: %v", e)
				return
			}
			if len(pevents) > 0 {
				f.lastEventsMutex.Lock()
				f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
				f.lastEventsMutex.Unlock()
				resultsChan <- pevents
			}
		}
		pool.Process(filterFunc)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		filterFunc := func() {
			startBlock := f.eventToStartBlock["RevisionSigned"]
			e, pevents := f.startFilterRevisionSigned(startBlock, []*model.Event{})
			if e != nil {
				log.Errorf("Error retrieving RevisionSigned: err: %v", e)
				return
			}
			if len(pevents) > 0 {
				f.lastEventsMutex.Lock()
				f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
				f.lastEventsMutex.Unlock()
				resultsChan <- pevents
			}
		}
		pool.Process(filterFunc)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		filterFunc := func() {
			startBlock := f.eventToStartBlock["RevisionUpdated"]
			e, pevents := f.startFilterRevisionUpdated(startBlock, []*model.Event{})
			if e != nil {
				log.Errorf("Error retrieving RevisionUpdated: err: %v", e)
				return
			}
			if len(pevents) > 0 {
				f.lastEventsMutex.Lock()
				f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
				f.lastEventsMutex.Unlock()
				resultsChan <- pevents
			}
		}
		pool.Process(filterFunc)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		filterFunc := func() {
			startBlock := f.eventToStartBlock["RoleAdded"]
			e, pevents := f.startFilterRoleAdded(startBlock, []*model.Event{})
			if e != nil {
				log.Errorf("Error retrieving RoleAdded: err: %v", e)
				return
			}
			if len(pevents) > 0 {
				f.lastEventsMutex.Lock()
				f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
				f.lastEventsMutex.Unlock()
				resultsChan <- pevents
			}
		}
		pool.Process(filterFunc)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		filterFunc := func() {
			startBlock := f.eventToStartBlock["RoleRemoved"]
			e, pevents := f.startFilterRoleRemoved(startBlock, []*model.Event{})
			if e != nil {
				log.Errorf("Error retrieving RoleRemoved: err: %v", e)
				return
			}
			if len(pevents) > 0 {
				f.lastEventsMutex.Lock()
				f.lastEvents = append(f.lastEvents, pevents[len(pevents)-1])
				f.lastEventsMutex.Unlock()
				resultsChan <- pevents
			}
		}
		pool.Process(filterFunc)
		wg.Done()
	}()

	go func() {
		wg.Wait()
		done <- true
		log.Info("Filtering routines complete")
	}()

Loop:
	for {
		select {
		case <-done:
			break Loop
		case pevents := <-resultsChan:
			f.pastEventsMutex.Lock()
			pastEvents = append(pastEvents, pevents...)
			f.pastEventsMutex.Unlock()
		}
	}
	log.Infof("Total events found: %v", len(pastEvents))
	return nil, pastEvents
}

func (f *NewsroomContractFilterers) startFilterContentPublished(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for ContentPublished for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.NewsroomContractContentPublishedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterContentPublished(
			opts,
			[]common.Address{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: ContentPublished for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: ContentPublished for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: ContentPublished for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("ContentPublished", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("ContentPublished events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *NewsroomContractFilterers) startFilterNameChanged(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for NameChanged for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.NewsroomContractNameChangedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterNameChanged(
			opts,
		)
		if err == nil {
			log.Infof("Successful filter: NameChanged for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: NameChanged for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: NameChanged for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("NameChanged", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("NameChanged events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *NewsroomContractFilterers) startFilterOwnershipRenounced(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for OwnershipRenounced for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.NewsroomContractOwnershipRenouncedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterOwnershipRenounced(
			opts,
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: OwnershipRenounced for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: OwnershipRenounced for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: OwnershipRenounced for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("OwnershipRenounced", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("OwnershipRenounced events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *NewsroomContractFilterers) startFilterOwnershipTransferred(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for OwnershipTransferred for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.NewsroomContractOwnershipTransferredIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterOwnershipTransferred(
			opts,
			[]common.Address{},
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: OwnershipTransferred for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: OwnershipTransferred for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: OwnershipTransferred for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("OwnershipTransferred", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("OwnershipTransferred events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *NewsroomContractFilterers) startFilterRevisionSigned(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for RevisionSigned for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.NewsroomContractRevisionSignedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterRevisionSigned(
			opts,
			[]*big.Int{},
			[]*big.Int{},
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: RevisionSigned for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: RevisionSigned for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: RevisionSigned for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("RevisionSigned", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("RevisionSigned events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *NewsroomContractFilterers) startFilterRevisionUpdated(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for RevisionUpdated for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.NewsroomContractRevisionUpdatedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterRevisionUpdated(
			opts,
			[]common.Address{},
			[]*big.Int{},
			[]*big.Int{},
		)
		if err == nil {
			log.Infof("Successful filter: RevisionUpdated for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: RevisionUpdated for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: RevisionUpdated for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("RevisionUpdated", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("RevisionUpdated events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *NewsroomContractFilterers) startFilterRoleAdded(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for RoleAdded for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.NewsroomContractRoleAddedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterRoleAdded(
			opts,
			[]common.Address{},
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: RoleAdded for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: RoleAdded for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: RoleAdded for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("RoleAdded", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("RoleAdded events added: %v", numEventsAdded)
	return nil, pastEvents
}

func (f *NewsroomContractFilterers) startFilterRoleRemoved(startBlock uint64, pastEvents []*model.Event) (error, []*model.Event) {
	var opts = &bind.FilterOpts{
		Start: startBlock,
	}

	log.Infof("Filtering events for RoleRemoved for contract %v starting at block %v", f.contractAddress.Hex(), startBlock)
	var itr *contract.NewsroomContractRoleRemovedIterator
	var err error
	maxRetries := 3
	retry := 0
	for {
		itr, err = f.contract.FilterRoleRemoved(
			opts,
			[]common.Address{},
			[]common.Address{},
		)
		if err == nil {
			log.Infof("Successful filter: RoleRemoved for contract %v", f.contractAddress.Hex())
			break
		}
		if retry >= maxRetries {
			log.Errorf("Failed filter: RoleRemoved for contract %v: err: %v", f.contractAddress.Hex(), err)
			return err, pastEvents
		}
		log.Infof("Retrying filter: RoleRemoved for contract %v: err: %v", f.contractAddress.Hex(), err)
		retry++
	}
	beforeCount := len(pastEvents)
	nextEvent := itr.Next()
	for nextEvent {
		modelEvent, err := model.NewEventFromContractEvent("RoleRemoved", f.ContractName(), f.contractAddress, itr.Event, ctime.CurrentEpochSecsInInt64(), model.Filterer)
		if err != nil {
			log.Errorf("Error creating new event: event: %v, err: %v", itr.Event, err)
			continue
		}
		pastEvents = append(pastEvents, modelEvent)
		nextEvent = itr.Next()
	}
	numEventsAdded := len(pastEvents) - beforeCount
	log.Infof("RoleRemoved events added: %v", numEventsAdded)
	return nil, pastEvents
}
